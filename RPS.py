import random

"""
- player: the main function that receive the opponent previous play and return my play.
- manage_strategies: a function that handles all strategies inputs, outputs and scores and returns a play
generated by the best strategy according to the strategies score.
- update_strategies_score: a function that update the score of each strategy based on the previous step
using its play against the opponent play.In another words, it updates the score based on the true outcome of the previous round.
- get_reward: a function that applies the rules of the game to find the winner. The values are 1 for a win, -1 for a defeat, and 0 for a tie.
- random_agent: using random.choice to generate a random play from three options 'R', 'P', and 'S'.
- semi_random_agent: using random.choice to generate a random play from two options based on the opponent play.
- forsee_v1: It generates a pattern based on the opponent previous play without any randomness.
- forsee_v2: It generates a pattern based on my previous play without any randomness.
- greedy: Using the previous round plays, predicts the best next play based on the score. The score is updated each round.
ex: my previous play is R and opponent play(state) is S so based on the score it chooses the maximum between RSR, RSP and RSS to decide the next play(action).
the score of a the state-action pair is 0 for a win, -1 for a tie and -2 for a defeat.
"""

def player(prev_play,opponent_history=[],my_history=[], strategies_history=[],strategies_score=[],state_action_pair = []):
    if prev_play =="":
      opponent_history.clear()
      my_history.clear()
      strategies_score.clear()
      strategies_history.clear()
      state_action_pair.clear()
      for _ in range(5):
        strategies_history.append([])
        strategies_score.append(0)
      state_action_pair.append({'RRR':0,'RRP':0,'RRS':0,'RPR':0,'RPP':0,'RPS':0,'RSR':0,'RSP':0,'RSS':0,'PRR':0,'PRP':0,'PRS':0,'PPR':0,'PPP':0,'PPS':0,'PSR':0,'PSP':0,'PSS':0,'SRR':0,'SRP':0,'SRS':0,'SPR':0,'SPP':0,'SPS':0,'SSR':0,'SSP':0,'SSS':0})
    actions=['R','P','S']
    strategies_number = 5
    opponent_history.append(prev_play)
    game_round = len(opponent_history)
    my_play, state_action_pair,strategies_history = manage_strategies(actions, opponent_history,my_history,state_action_pair,game_round,strategies_history,strategies_number,strategies_score)
    my_history.append(my_play)
    return(my_play)


def manage_strategies(actions, opponent_history,my_history,state_action_pair,game_round,strategies_history,strategies_number,strategies_score):
    if game_round <= 3:
        start = False
        my_play = random_agent(actions)

    else:
        start = True
    if (game_round >= 3):
        reward = get_reward(my_history[-1], opponent_history[-1])
        if(start):
            strategies_score = Update_strategies_score(strategies_history, opponent_history[-1], strategies_score,strategies_number)
            best_strategy =strategies_score.index(max(strategies_score))

        greedy_play, state_action_pair = greedy(state_action_pair, my_history[-2]+opponent_history[-2],opponent_history[-1],my_history[-1],reward,actions)
        foresee_v1_play = foresee_v1(opponent_history[-1])
        foresee_v2_play = foresee_v2(my_history[-1])
        random_agent_play = random_agent(actions)
        semi_random_agent_play = semi_random_agent(opponent_history[-1])
        my_play_candidates = [random_agent_play, semi_random_agent_play, foresee_v1_play,foresee_v2_play ,greedy_play]
        for i in range(strategies_number):
            strategies_history[i].append(my_play_candidates[i])
        if(start):
            my_play = my_play_candidates[best_strategy]
    return my_play, state_action_pair, strategies_history

def Update_strategies_score(strategies_history, prev_opponent_play, strategies_score,strategies_number):
    for i in range(strategies_number):
        strategies_score[i] += get_reward(strategies_history[i][-1],prev_opponent_play)
    return strategies_score

def random_agent(actions):
    shuffled_actions = actions
    random.shuffle(shuffled_actions)
    my_play= random.choice(shuffled_actions)
    return my_play

def semi_random_agent(prev_play):
  if(prev_play=='R'):
    my_play =random.choice(['P','S'])
  elif(prev_play == 'P'):
    my_play =random.choice(['R','S'])
  else:
    my_play =random.choice(['R','P'])
  return my_play


def foresee_v1(prev_play):
  if(prev_play=='R'):
    my_play ='S'
  elif(prev_play == 'P'):
    my_play ='R'
  else:
    my_play = 'P'
  return my_play

def foresee_v2(my_prev_play):
  if(my_prev_play=='R'):
    my_play ='S'
  elif(my_prev_play == 'P'):
    my_play ='R'
  else:
    my_play = 'P'
  return my_play

def greedy(state_action_pair, prev_state,opponent_prev_play,my_prev_play,reward,actions):
    # prev_state = my_history[-2]+oppenent_history[-2]
    shift = 0
    if reward-1 == 0:
          shift = 0 # if shift is 1, wins against player1 increases but against player2 decreases
    state_action_pair[0][prev_state+my_prev_play]+= reward - 1 + shift
    available_actions = [state_action_pair[0][my_prev_play+opponent_prev_play+i] for i in ['R','P','S']]
    best_action = available_actions.index(max(available_actions))
    my_play = actions[best_action]
    return my_play, state_action_pair

def get_reward(play1,play2):
  if(play1 == 'R'):
    if(play2 == 'S'):
      res = 1
    elif(play2=='P'):
      res = -1
    else:
      res = 0
  if(play1 == 'P'):
    if(play2 == 'R'):
      res = 1
    elif(play2=='S'):
      res = -1
    else:
      res = 0
  if(play1 == 'S'):
    if(play2 == 'P'):
      res = 1
    elif(play2=='R'):
      res = -1
    else:
      res = 0
  return res
